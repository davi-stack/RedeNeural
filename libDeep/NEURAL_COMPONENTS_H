// NeuralComponents.h
#ifndef NEURAL_COMPONENTS_H
#define NEURAL_COMPONENTS_H

#include <bits/stdc++.h>

using namespace std;
class Matrix {
private:
     static bool randomGeneratorInitialized;
public:
Matrix(){
    
}
void printJogoDaVelha(){
    for(int i=0;i<rows;i++){
        for(int j=0;j<cols;j++){
            if(data[i][j]==-1) cout << "O";
            if(data[i][j]==1) cout << "X";
            if(data[i][j]==0) cout << "-";
            cout << " ";
        }
        cout << endl;
    }
}

static Matrix vectorTomatriz(double * arr, int n) {
    Matrix re(n, n);
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            re.data[i][j] = arr[i * n + j]; // Mapeia o vetor linear para a matriz
        }
    }
    return re;
}


std::vector<std::vector<double>> data;
    int rows;
    int cols;
    
    // Constructor to create a matrix of a given size initialized to 0
    Matrix(int i, int j) : rows(i), cols(j) {
        data.resize(i, std::vector<double>(j, 0.0));
        initializeRandomGenerator();
    }

   
    
    // Apply a function to each element in the matrix
    static Matrix applyFunction(Matrix& mat, std::function<double(double)> func) {
        Matrix result(mat.rows, mat.cols);
        for (int i = 0; i < mat.rows; ++i) {
            for (int j = 0; j < mat.cols; ++j) {
                result.data[i][j] = func(mat.data[i][j]);
            }
        }
        return result;
    }

    // Apply a function to each element in the matrix
    void applyFunction(std::function<double(double)> func) {
        for (int i = 0; i < rows; ++i) {
            for (int j = 0; j < cols; ++j) {
                data[i][j] = func(data[i][j]);
            }
        }
    }
    
    // Função para multiplicar uma matriz por um escalar e retornar uma nova matriz
    static Matrix scalarMultiply(const Matrix& mat, double scalar) {
        Matrix result = mat;  // Cria uma cópia de mat

        // Usando uma lambda function para multiplicar cada elemento pelo escalar
        applyFunction(result, [scalar](double value) { return value * scalar; });

        return result;  // Retorna a nova matriz resultante
    }
    //function to transpose matrix a
    static Matrix transpose(Matrix& mat) {
        Matrix transposed(mat.cols, mat.rows); // Nova matriz com dimensões invertidas

        for (int i = 0; i < mat.rows; ++i) {
            for (int j = 0; j < mat.cols; ++j) {
                transposed.data[j][i] = mat.data[i][j]; // Trocando linhas por colunas
            }
        }

        return transposed;
    }
    // Convert the matrix to a string for display
    string toString() {
        std::ostringstream oss;
        for (int i = 0; i < rows; ++i) {
            for (int j = 0; j < cols; ++j) {
                oss << data[i][j] << " ";
            }
            oss << "\n";
        }
        return oss.str();
    }
    // Getter for a specific element
    double getElement(int i, int j) const {
        return data[i][j];
    }
    // Setter for a specific element
    void setElement(int i, int j, double val) {
        data[i][j] = val;
    }
    // Static function to create a matrix from a vector
    static Matrix matrixFromVector(vector<double> aux) {
        Matrix result(static_cast<int>(aux.size()), 1);
        for(int i = 0; i < aux.size(); i++) {
            result.data[i][0] = aux[i];
        }
        return result;
    }
 
    static void initializeRandomGenerator() {
        if (!randomGeneratorInitialized) {
            std::srand(static_cast<unsigned>(std::time(nullptr)));
            randomGeneratorInitialized = true;
        }
    }
    
    void randomize() {
        for (int i = 0; i < rows; ++i) {
            for (int j = 0; j < cols; ++j) {
                data[i][j] = static_cast<double>(std::rand()) / RAND_MAX;
            }
        }
    }
    
    //product hadamard
    static Matrix hadamard(Matrix a, Matrix b) {
        if (a.rows != b.rows || a.cols != b.cols) {
            throw std::invalid_argument("Matrices dimensions must match for addition.");
        }

        Matrix result(a.rows, a.cols);
        for (int i = 0; i < a.rows; i++) {
            for (int j = 0; j < a.cols; j++) {
                result.setElement(i, j, a.getElement(i, j) * b.getElement(i, j));
            }
        }
        return result;
    }
    static Matrix add(const Matrix& a, const Matrix& b) {
        if (a.rows != b.rows || a.cols != b.cols) {
            throw std::invalid_argument("Matrices must be of the same dimensions to add.");
        }

        Matrix result(a.rows, a.cols);
        for (int i = 0; i < a.rows; ++i) {
            for (int j = 0; j < a.cols; ++j) {
                result.data[i][j] = a.data[i][j] + b.data[i][j];
            }
        }
        return result;
    }

   
    static Matrix subtract(const Matrix& a, const Matrix& b) {
        if (a.rows != b.rows || a.cols != b.cols) {
            throw std::invalid_argument("Matrices must be of the same dimensions to subtract.");
        }

        Matrix result(a.rows, a.cols);
        for (int i = 0; i < a.rows; ++i) {
            for (int j = 0; j < a.cols; ++j) {
                result.data[i][j] = a.data[i][j] - b.data[i][j];
            }
        }
        return result;
    }
    
   


    
    // Add two matrices
    Matrix add(Matrix other) const {
        cout << rows <<endl << other.rows<< endl;
        // if (rows != other.rows || cols != other.cols) {
        //     throw std::invalid_argument("Matrices dimensions must match for addition.");
        // }

        Matrix result(rows, cols);
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                result.setElement(i, j, this->getElement(i, j) + other.getElement(i, j));
            }
        }
        return result;
    }

    // Multiply two matrices (static method)
    static Matrix multiply(const Matrix& a, const Matrix& b) {
        
        if (a.cols != b.rows) {
            throw std::invalid_argument("Matrices with incompatible dimensions for multiplication.");
        }

        Matrix result(a.rows, b.cols);
        for (int i = 0; i < result.rows; i++) {
            for (int j = 0; j < result.cols; j++) {
                double sum = 0;
                for (int k = 0; k < a.cols; k++) { // or k < b.rows, since a.cols == b.rows
                    sum += a.data[i][k] * b.data[k][j];
                }
                result.data[i][j] = sum;
            }
        }
        return result;
    }

    // Display the matrix
    void display() {
        cout << this->toString();
    }
};



double sigmoide(double a) {
    return 1.0 / (1.0 + std::exp(-a));
}
double dSigmoide(double a){
    return a *(1 - a);
}
class RedeNeural{
    public:
    double learningRate;
    double input;
    double output;
    double oculta;
    
    Matrix in_oc;
    Matrix oc_out;
    
    //bias to acelerate the process
    Matrix bias_in_oc;
    Matrix bias_oc_out;
    
    Matrix peso_in_oc;
    Matrix peso_oc_out;
    
    RedeNeural(double i, double oc, double ou, double lernin) : input(i), output(ou), oculta(oc), in_oc(i, 1), oc_out(oc, 1),
    peso_in_oc(oc, i), peso_oc_out(ou, oc), bias_in_oc(oc, 1), bias_oc_out(ou, 1) {
    bias_oc_out.randomize();
    bias_in_oc.randomize();
    peso_oc_out.randomize();
    peso_in_oc.randomize();
    this->learningRate = lernin;
        
    }

    // void feedforward(vector<int> arr){
    // Matrix input = Matrix::matrixFromVector(arr);  // Corrigido para usar ::    }
    // Matrix hidden = Matrix::multiply(this->peso_in_oc, input);
    // hidden.add(this->bias_in_oc);
    // cout << hidden.toString() << endl;
    // hidden.applyFunction([](int x) -> double { return sigmoide(x); });
    // cout << hidden.toString() << endl;
    // }
    Matrix feedforward(Matrix input) {
        //INPUT -> HIDDEN
        Matrix hidden = Matrix::multiply(peso_in_oc, input);
        hidden.add(bias_in_oc);
        //std::cout << hidden.toString() << std::endl;

        // Aplicando a função sigmoide a cada elemento da matriz 'hidden'
        hidden.applyFunction(sigmoide);
        //std::cout << hidden.toString() << std::endl;
        
        /*
        HIDDEN -> OUTPUT
        */
        Matrix output = Matrix::multiply(peso_oc_out, hidden);
        output = output.add(bias_oc_out);
        output.applyFunction(sigmoide);
        return output;
        
    }
    
    void train(Matrix input, Matrix expected) {
        //INPUT -> HIDDEN
        Matrix hidden = Matrix::multiply(peso_in_oc, input);
        hidden.add(bias_in_oc);
        //std::cout << hidden.toString() << std::endl;

        // Aplicando a função sigmoide a cada elemento da matriz 'hidden'
        hidden.applyFunction(sigmoide);
        //std::cout << hidden.toString() << std::endl;
        
        /*
        HIDDEN -> OUTPUT
        */
        Matrix output = Matrix::multiply(peso_oc_out, hidden);
        output = output.add(bias_oc_out);
        output.applyFunction(sigmoide);
        
        
        //BACKPROPAGATION
        
        //OUTPUT -> HIDDEN 
        Matrix output_Error = Matrix::subtract(expected, output);
        Matrix outputD = Matrix::applyFunction(output, dSigmoide);//derivada da saída(sigmóide)
        Matrix hiddenT = Matrix::transpose(hidden);//transposed HIDDEN
        Matrix gradient = Matrix::hadamard(output_Error, outputD);
        gradient = Matrix::scalarMultiply(gradient, learningRate);
        
        //ajust bias
        bias_oc_out.add(gradient);
        
        
        Matrix peso_oculta_saida_delta = Matrix::multiply(gradient, hiddenT);
        this->peso_oc_out.add(peso_oculta_saida_delta);
        
        
        
        
        
        //HIDDEN -> input
        Matrix peso_oc_outT = Matrix::transpose(peso_oc_out);
        Matrix hiddenError = Matrix::multiply(peso_oc_outT, output_Error);//peso oculta
        Matrix d_hidden = Matrix::applyFunction(hidden, sigmoide);
        Matrix input_T = Matrix::transpose(input);
        Matrix gradient_oc = Matrix::hadamard(hiddenError, d_hidden);
        gradient_oc = Matrix::scalarMultiply(gradient_oc,learningRate );
        
        
        //ajust bias hidden -> input
        bias_in_oc.add(gradient_oc);
        Matrix pesos_in_oc_deltas = Matrix::multiply(gradient_oc, input_T);
        peso_in_oc.add(pesos_in_oc_deltas);
    }
    Matrix predict(Matrix input){
    Matrix hidden = Matrix::multiply(peso_in_oc, input);
    hidden.add(bias_in_oc);
    
    Matrix output = Matrix::multiply(peso_oc_out, hidden);
    output.add(bias_oc_out);
    output.applyFunction(sigmoide);
    
    return output;
    }
};
 
bool Matrix::randomGeneratorInitialized = false;

#endif // NEURAL_COMPONENTS_H
